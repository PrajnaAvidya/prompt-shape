TOP PRIORITY
- redo fucking everything
- SETTLE THE FUCKING TEMPLATE VS SLOT VS VARIABLE THING ONCE AND FOR ALL
-- I think it should only be called a template if it's a file that gets loaded/rendered
- inline definitions ie {currentQuestion}Test{/currentQuestion}
-- or {foo="bar"} and then I change file loading syntax

return to loading variables as one of 3 types: string, number, template. templates are any variable loaded from file or defined as multi line.


- use variable as param
- do isNumeric on trimmed inline templates to see if the variables should be typed as numbers

then...
REDO RENDERING SO ITS FULLY RECURSIVE (starts at the top level and works down template/collection definitions and renders like a tree)
- look for name conflicts
// (old) TODO what steps to take in compilation?
// remove comments
// get/validate all slot definitions, error if there are unmatched opening or closing tags
// remove slot definitions
// check for collection defs, load them (error if referencing unknown snippets) and remove those from the page
// render collections
// render all variables (will need to be called recursively because snippets can contain vars)
// we're done? (no we still need to run the gpt query)
- correct parsing of variable tags inside variables
- add explicit step to check for unpaired (or incorrectly ordered) tags before rendering

config
- allow absolute/parent paths for template file load
- show debug messages

collection stuff? (low priority until I actually use them)
- pull collection stuff into a new branch until its ready
- basic iterating
- validate the names of collection vars
- make collection variable name accessible
- index access
- appending
- for loops?

nice to haves
- 1 liner for defining string/numeric vars
- also 1 liner to load/render file inline
- file templates with local parameters
- tag for making gpt calls e.g. %gpt% (do they need an option to be deferred vs instant)

other random cool ideas
- placeholders for responses -- i.e. as it scans down the file you can define a thing where it executes up until there and then captures the response and either adds it as another chatgpt message, or captures it into a variable

===

if I were to use this to aid myself in writing this very app what would I need?
- loading variables from files (params not needed) -- for including code/text samples
-- is this really it? I don't think I need collections, are they more useful for writing? I guess I can have a collection of code samples
- ability to auto feed final output to gpt. I should look into using an existing openai library, no need to write my own thing for that.
