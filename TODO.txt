TOP PRIORITY
- use variable as param
- do isNumeric on trimmed inline templates to see if the variables should be typed as numbers
-- maybe I need a third variable type (and auto-detect on load)? string, numeric, template.
- tag for making gpt calls e.g. %gpt% (do they need an option to be deferred vs instant)

REDO RENDERING SO ITS FULLY RECURSIVE (starts at the top level and works down template/collection definitions and renders like a tree)
- look for name conflicts
// (old) TODO what steps to take in compilation?
// remove comments
// get/validate all slot definitions, error if there are unmatched opening or closing tags
// remove slot definitions
// check for collection defs, load them (error if referencing unknown snippets) and remove those from the page
// render collections
// render all variables (will need to be called recursively because snippets can contain vars)
// we're done? (no we still need to run the gpt query)

config
- allow absolute/parent paths for template file load
- show debug messages

collection stuff? (low priority until I actually use them)
- pull collection stuff into a new branch until its ready
- basic iterating
- validate the names of collection vars
- make collection variable name accessible
- index access
- appending
- for loops?

nice to haves
- 1 liner for defining string/numeric vars
- also 1 liner to load/render file inline
- file templates with local parameters

other random cool ideas
- placeholders for responses -- i.e. as it scans down the file you can define a thing where it executes up until there and then captures the response and either adds it as another chatgpt message, or captures it into a variable

===

if I were to use this to aid myself in writing this very app what would I need?
- loading variables from files (params not needed) -- for including code/text samples
-- is this really it? I don't think I need collections, are they more useful for writing? I guess I can have a collection of code samples
- ability to auto prompt/output the final product (%gpt% tags or whatever). I should look into chaining with an existing openai library, no need to write my own thing.
